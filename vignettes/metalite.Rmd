---
title: "Introduction to metalite"
output:
  rmarkdown::html_vignette
resource_files:
   - package_manual.pdf
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Introduction to metalite}
---

```{r, echo = FALSE, message = FALSE, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

```{r, message = FALSE}
library(metalite)
library(r2rtf)
```

# Overview

The purpose of `metalite` is to define a unified data structure to save meta information 
for analysis & reporting (A&R) based on ADaM datasets in clinical trial development. 

The R package is design to 

- standardize function input for analysis and reporting. 
- enables pipes (`|>`).
- reduce manual steps to maintain SDLC documentation.
- ensure consistency between analysis specification, mock and results.

We build `metalite` to enable principals below:

- Automation: a function call is better than a checklist. 
- Single-entry: enter in one place, sync to all delivery. 
  - e.g. Enter data source one time for all AE analysis.
- End-to-end: cover all steps in SDLC from define to delivery.

# Use cases 

`metalite` build a foundation to simplify tool development. 
For example, `metalite` can be used to: 

- standardize input and output for A&R functions. 
- create A&R grid 
- create mock table 
- create and validate A&R results
- trace analysis records 

`metalite` need to work with other R packages to complete the work. 
We illustrate the idea in the diagram below.

```{r, out.width = "100%", out.height = "400px", echo = FALSE, fig.align = "center"}
path <- system.file("figures/design-diagram.png", package = "metalite")
knitr::include_graphics(path)
```

# Mental model

The typical analysis and reporting based on ADaM data contain three layers.

- Data
- Analysis Plan 
- Analysis Meta data

The design of `metalite` is to align the layers using `meta_adam`, and `define_xxx` functions. 

## Example: adverse events analysis

We use a simplified adverse events analysis as an example to illustrate the mental model. 

- Data (`meta_adam`):
  + Observation level: ADAE
  + Population level:  ADSL

For a typical adverse events analysis, 
the AE records is saved in ADAE (observation level) and 
the population information is saved in ADSL (population level). 
With demo ADaM datasets in `r2rtf` package, we can construct an object as below using `meta_adam`. 

```{r}
meta_adam(observation = r2rtf_adae, 
          population = r2rtf_adsl) 
```

- Analysis Plan (`define_plan`): specification of analysis 
  + A&R grid 
  + validation tracker 
  + mock table

We also need to understand the analysis plan for the adverse events analysis. 
Specifically, the details of each table, listing and figure (TLF)

Here we use two helper functions (`plan` and `add_plan`) to create an analysis plan.
The analysis plan is a dataframe that indicate the specification of each TLF.
In the code below, we construct 10 TLFs based on different combination of 
analysis function, population, observation and parameter. 

```{r}
plan <- plan(analysis = "ae_summary", population = "apat", 
             observation = c("wk12", "wk24"), parameter = "any;rel;ser") |>
  
  add_plan(analysis = "ae_specific", population = "apat", 
           observation = c("wk12", "wk24"), 
           parameter = c("any", "aeosi", "rel", "ser"))

plan
```

Then, we can define the analysis plan using `define_plan`.

```{r}
meta_adam(population = r2rtf_adsl,
          observation = r2rtf_adae) |>
  define_plan(plan)
```
  
- Analysis Meta data: 
  + population (`define_population`): e.g.: `name = "apat", group = "TRT01A", subset = SAFFL == "Y"` 
  + observation (`define_observation`): e.g.: `name = "wk12", group = "TRTA", subset = SAFFL == "Y", label = "Weeks 0 to 12"` 
  + parameter (`define_parameter`): e.g.: `name = "ser", subset = AESER == "Y", label = "serious adverse events"`
  + analysis (`define_analysis`): AE summary, Specific AE table, Rainfall plot (static or interactive), Volcano plot, etc

There are more details that needs to be defined in the metadata information. 
For example, how to select the APaT population from the `ADSL` dataset. 
This is achieved by defining the population. 
We have defined some built-in information that follows an A&R conventions. 
So, the programs know the meaning of "apat" as below. 

```{r}
meta_adam(population = r2rtf_adsl, 
          observation = r2rtf_adae) |>
  
  define_plan(plan) |>
  
  define_population(name = "apat")
```

Some project specific information still needs to be provided by study team 
such as the group variable name and subset flag condition. 

```{r}
meta_adam(population = r2rtf_adsl, 
          observation = r2rtf_adae) |>
  
  define_plan(plan) |>
  
  define_population(name = "apat",
                    group = "TRT01A", 
                    subset = SAFFL == "Y")
```

Similarly, we can define other meta information 
for analysis observation, parameter and function.
We will also use `meta_build` to add default values for other `name` that is not specified. 

> In `metalite`, we save this demo example in `meta_dummy()` to illustrate different use cases.

```{r}
meta_adam(population = r2rtf_adsl, 
          observation = r2rtf_adae) |>
  
  define_plan(plan = plan) |>
  
  define_population(name = "apat",
                    group = "TRT01A", 
                    subset = SAFFL == "Y") |>
  
  define_observation(name = "wk12",
                  group = "TRTA", 
                  subset = SAFFL == "Y", 
                  label = "Weeks 0 to 12") |>
  
  define_observation(name = "wk24",
                  group = "TRTA", 
                  subset = AOCC01FL == "Y",    # just for demo, another flag shall be used.  
                  label = "Weeks 0 to 24") |>
  
  define_parameter(name = "rel", 
                subset = AEREL %in% c("POSSIBLE", "PROBABLE")) |>
  
  define_parameter(name = "aeosi", 
                subset = AEOSI == "Y", 
                label = "adverse events of special interest") |> 
  
  define_analysis(name = "ae_summary", 
                  title = "Summary of Adverse Events") |>
  
  meta_build()
```

As a developer, you can reuse those meta information for your development. 
It also allow developers to **standardize** the input of their functions.
So the `plan$analysis` is analysis name. `meta` and other columns in `plan` are function arguments

```{r, eval = FALSE}
ae_summary(meta, 
           population, 
           observation, 
           parameter, ...)
```




